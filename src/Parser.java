import java.util.List;

/**
 * A parser that p : [token] -> program
 */
public class Parser {
    /**
     * @param container the list of tokens and variables generated by the lexer
     * @return the program that contains all the statements in the program
     */
    public static ProgramHandler.Program parse(Pair<List<Token>, List<String>> container) {

        // pulls the individual lists from the pair for convenience
        List<Token> tokens = container.first;
        List<String> vars = container.second;

        // creates a new program where commands can be assigned
        ProgramHandler.Program program = new ProgramHandler.Program();

        // goes through each token
        while (!tokens.isEmpty()) {
            Token token = tokens.remove(0);
            // removes the first one and stores it
            if (token != Token.SemiColon) {
                switch (token) {
                    case Clear -> {
                        if (tokens.remove(0) == Token.Var) {
                            // creates a clear statement, creates a Variable instance from the name of the next variable
                            ProgramHandler.ClearStatement statement = new ProgramHandler.ClearStatement();
                            statement.v = new ProgramHandler.Variable(vars.remove(0));
                            // adds the statement to the program to be run
                            program.stmts.add(statement);
                        } else {
                            System.err.println("Clear not followed by variable");
                        }
                    }
                    case Incr -> {
                        if (tokens.remove(0) == Token.Var) {
                            // creates an incr statement, creates a Variable instance from the name of the next variable
                            ProgramHandler.IncrStatement statement = new ProgramHandler.IncrStatement();
                            statement.v = new ProgramHandler.Variable(vars.remove(0));
                            // adds the statement to the program to be run
                            program.stmts.add(statement);
                        } else {
                            System.err.println("Incr not followed by variable");
                        }
                    }
                    case Decr -> {
                        if (tokens.remove(0) == Token.Var) {
                            // creates a decr statement, creates a Variable instance from the name of the next variable
                            ProgramHandler.DecrStatement statement = new ProgramHandler.DecrStatement();
                            statement.v = new ProgramHandler.Variable(vars.remove(0));
                            // adds the statement to the program to be run
                            program.stmts.add(statement);
                        } else {
                            System.err.println("Decr not followed by variable");
                        }
                    }
                    case While -> {
                        // creates a while loop
                        ProgramHandler.WhileLoop loop = new ProgramHandler.WhileLoop();
                        // uses the expression parser to develop an expression
                        Expression.Expr expr = eParse(container);
                        // gives the loop the expression
                        loop.expr = expr;
                        // recursively pass until next end to create program to be looped
                        loop.p = parse(container);
                        // add it to this programs statements
                        program.stmts.add(loop);
                    }
                    case End -> {
                        return program;
                    }
                    case Var, Number -> {
                        System.err.print("Something went wrong during parse around " + token);
                        for (int i = 0; i < 5; i++) {
                            if (tokens.size() > i) {
                                System.err.print(tokens.get(i) + " ");
                            }
                        }
                        System.err.println();
                    }
                }
            }
        }

        return program;
    }

    /**
     * @param container contains tokens and variable names
     * @return
     */
    private static Expression.Expr eParse(Pair<List<Token>, List<String>> container){
        List<Token> tokens = container.first;
        List<String> vars = container.second;
        Expression.Expr e = null;

        while (!tokens.isEmpty()) {
            // takes first token
            Token token = tokens.remove(0);
            switch (token) {
                case Var -> {
                    // if expression doesnt exist, create one
                    if (e == null) {
                        e = new Expression.VarExpr(vars.remove(0));
                    } else {
                        // this means 2 variables or numbers are in a row which is meaningless
                        System.err.print("Expression not valid around " + token);
                        for (int i = 0; i < 5; i++) {
                            if (i < tokens.size())
                                System.err.print(tokens.get(i));
                        }
                        System.exit(1);
                    }
                } case Number -> {
                    if (e == null) {
                        // if expression doesnt exist, create one
                        e = new Expression.LiteralExpr(new Expression.IntVal(Integer.parseInt(vars.remove(0))));
                    } else {
                        // this means 2 variables or numbers are in a row which is meaningless
                        System.err.print("Expression not valid around " + token);
                        for (int i = 0; i < 5; i++) {
                            if (i < tokens.size())
                                System.err.print(tokens.get(i));
                        }
                        System.exit(1);
                    }
                } case Not -> {
                    if (e != null) {
                        // if preceded by an expression continue
                        Expression.Expr rhs = eParse(container);
                        e = new Expression.NotExpr(e, rhs);
                    } else {
                        // this means not isn't preceded by a variable or number, making it invalid
                        System.err.print("Expression not valid around " + token);
                        for (int i = 0; i < 5; i++) {
                            if (i < tokens.size())
                                System.err.print(tokens.get(i));
                        }
                        System.exit(1);
                    }
                } case Do, End, SemiColon -> {
                    return e;
                }
            }
        }
        System.err.println("Expr never ended");
        System.exit(1);
        // code never reached, here to satisfy javac
        return new Expression.LiteralExpr(new Expression.IntVal(1));
    }
}
